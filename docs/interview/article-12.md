---
title: 3D图形学面试题
---

# 3D图形学面试题

## 什么是 WebGL？什么是 Three.js？请解释three.js中的WebGL和Canvas的区别？

1. WebGL(全写Web Graphics Library)是一种3D绘图协议，这种绘图技术标准允许把JavaScript和OpenGL ES 2.0结合在一起，通过增加OpenGL ES 2.0的一个JavaScript绑定，WebGL可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。

2. Three.js是一款基于JavaScript可直接运行GPU驱动游戏与图形驱动应用于浏览器的WebGL引擎，其库提供的特性与API以绘制3D场景于浏览器。

3. Canvas与WebGL的区别是canvas API提供二维绘图方式，图形的绘制主要通过CanvasRenderingContext2D接口完成，通过 canvas.getContext('2d') 获取二维图像绘图上下文；而WebGL  API可以在任何兼容canvas中的渲染2d和3d图形，WebGL API 提供三维接口，图形绘制主要通过WebGLRenderingContext接口完成，通过canvas.getContext('webgl')来获取WebGL上下文。

## Three.js它有什么特点和优势？以及它为什么会被广泛使用？

Three.js提供了一系列简化的API和工具，使得创建三维图形更加容易的展现在浏览器端。其抽象了底层的复杂性，提供了简单、一致的接口。提供基本的渲染功能之外，还包括了丰富的扩展，如光照、贴图、粒子系统等，可以满足不同类型的三维图形需求。Three.js有一个活跃的社区，提供了大量的文档、教程和示例，方便开发者学习和解决问题。
随着社会的信息化的发展，在数据可视化、图形/游戏引擎、交互演示、图形渲染、地图、VR、物品展示、室内设计、城市规划等方面Web端展示3D的需求大量增多，人们迫切需求一款能打开浏览器即可使用的便捷式3D开发引擎，而基于JavaScript的WebGL引擎Threejs恰好可以满足这一要求，所以得以大规模应用。

## GIS数据处理经验

我之前的地理信息数据处理经验主要是基于高德地图的使用。我在项目中使用过高德地图API来获取地理数据，并将其集成到我们的应用程序中。我熟悉高德地图提供的各种功能，例如地理编码、逆地理编码、路径规划和地图展示等。虽然我主要是通过高德地图来处理地理信息数据，但我也对地理坐标系和地理数据的基本概念有一定的了解。我相信我的经验可以帮助我快速适应其他地理信息处理工具或库，并在项目中进行有效地数据处理。

GeoJSON是一种用于表示地理空间数据的开放标准格式。它基于JSON（JavaScript Object Notation）格式，因此易于阅读和编写，并且广泛应用于Web开发和地理信息系统（GIS）中。

GeoJSON支持多种几何类型，包括点（Point）、线（LineString）、多段线（MultiLineString）、多边形（Polygon）和多部分多边形（MultiPolygon）。除了几何类型之外，GeoJSON还支持要素集合（FeatureCollection）以及单个要素（Feature），这使得它成为一种灵活的数据格式，能够表示复杂的地理信息数据结构。

```js
{
  "type": "Feature",
  "geometry": {
    "type": "Point",
    "coordinates": [100.0, 0.0]
  },
  "properties": {
    "name": "Null Island"
  }
}
```

OBJ（Wavefront .obj）：OBJ 是一种简单的文本文件格式，它包含了顶点、纹理坐标、法线等信息。OBJ 格式易于阅读和编辑，但不支持动画或复杂的材质。

STL（Stereolithography .stl）：STL 是一种二进制或文本文件格式，通常用于表示三角形网格表面。它是一种简单的格式，常用于快速原型制作和3D打印。

FBX（Autodesk .fbx）：FBX 是一种专有的二进制文件格式，由Autodesk开发。它支持几乎所有的三维数据类型，包括几何、材质、动画等，并且被广泛用于游戏开发、影视制作等领域。

Collada（.dae）：Collada 是一种开放的 XML 文件格式，用于在不同的三维软件之间交换数据。它支持几乎所有类型的三维数据，并且具有广泛的应用领域。

3DS（3D Studio .3ds）：3DS 是一种由Autodesk开发的二进制文件格式，常用于存储三维模型、场景和动画。尽管它有一些限制，但在早期的计算机图形中仍然被广泛使用。

PLY（Polygon File Format .ply）：PLY 是一种用于表示三维图形对象的文件格式，它允许存储各种属性，如颜色、透明度等。PLY 格式适用于点云数据和多边形网格。

AMF（Additive Manufacturing File Format .amf）：AMF 是一种用于描述增材制造过程中的三维对象的文件格式。它支持多材料、颜色和纹理，适用于3D打印等领域。

GLTF（GL Transmission Format .gltf）：GLTF 是一种基于 JSON 和二进制数据的文件格式，用于在WebGL等上下文中传输和加载三维模型。它是一种开放的标准格式，支持材质、动画、骨骼等。

## 什么是模型导入器(Model Loader)？Three.js中有哪些常用的模型导入器？

通常叫做模型加载器，一般用来加载外部特定格式的模型文件；常用的模型加载器有GLTFLoader GLTF模型加载器、OBJLoader OBJ模型加载器、STLLoader STL模型加载器、 FBXLoader动画模型加载器等等。

## 哪一种三维物体格式能够得到最好地支持？

推荐使用GLTF(gl传输格式)来对三维物体进行导入和导出,glTF(gl传输格式)是一种开放格式的规范 (open format specification), 用于更高效地传输、加载3D内容。该类文件以JSON(.gltf)格式或二进制（.glb）格式提供,外部文件存储贴图(.jpg、.png)和额外的二进制数据(.bin).一个glTF组件可传输一个或多个场景， 包括网格、材质、贴图、蒙皮、骨架、变形目标、动画、灯光以及摄像机等。

## 如何将three.js与WebGL结合使用？

Three.js基于WebGL构建，因此它与WebGL紧密集成。可以通过创建WebGLRenderer对象来启用WebGL渲染。此外，可以通过使用Three.js提供的各种实用工具和功能来简化WebGL的使用，如场景管理、光照、材质和动画等。

## Three.js 中的事件处理是如何工作的，如何处理用户输入？

Three.js 提供了鼠标和触摸事件监听器，你可以使用它们来捕捉用户的输入，例如点击、拖动和缩放等操作。通过事件处理，你可以实现交互性。

## 请解释 WebGL 渲染流水线（Rendering Pipeline）

WebGL 渲染流水线是一系列的步骤，用于将三维场景转化为最终的图像。这包括几何处理、光照计算、着色器执行和像素绘制等过程

## Three.js 中的性能优化技巧有哪些？

1. 合并几何体（Geometry Merge） ：如果你有多个相似的物体，可以将它们的几何体合并成一个，以减少渲染调用的数量。这可以通过 BufferGeometry 来实现。

2. 使用纹理集合（Texture Atlas） ：将多个小纹理图像合并成一个大的纹理图集，减少纹理切换和内存占用。

3. 减少光源数量：光源是渲染成本较高的因素之一。尽量减少不必要的光源，使用平行光或环境光来模拟光照效果。

4. 使用 LOD（Level of Detail） ：LOD 技术根据物体距离相机的远近，加载不同级别的细节模型。这有助于减少物体的多边形数量。

5. 开启硬件加速：确保浏览器启用了硬件加速，以充分利用 GPU 渲染。

6. 使用 Web Workers：将一些计算密集型任务放在 Web Workers 中，以防止阻塞主线程。

7. 使用 Occlusion Culling：当物体被遮挡时，不需要渲染它们。使用视锥体剔除和遮挡剔除技术来提高渲染效率。

8. 纹理压缩：使用纹理压缩格式，如 DXT、ETC 或 PVRTC，以减少纹理内存占用。

9. 事件处理的最小化：不要在每一帧都附加事件监听器，只在需要时附加。事件处理可能会引入性能开销。

10. 使用 requestAnimationFrame：使用 requestAnimationFrame 来控制渲染循环，以确保在性能允许的情况下渲染。

11. 使用外部模型格式：如果可能的话，使用 GLTF 格式的模型，因为它是 Three.js 中性能较高的模型格式。

12. 内存管理：当你不再需要物体或纹理时，记得手动释放它们的内存资源，以避免内存泄漏。

13. 渲染器设置：在创建渲染器时，选择合适的渲染器设置，如 antialiasing（抗锯齿）和 shadows（阴影），以平衡性能和图形质量。

14. 使用 GPU 功能：尽量使用 GPU 进行计算，例如使用着色器来执行复杂的渲染操作。

15. 避免频繁的渲染大小变化：频繁改变渲染画布的大小可能会导致性能下降，尽量避免这种情况。

16. 压缩和合并着色器：将着色器代码压缩和合并，以减少 HTTP 请求和提高加载速度。

17. 定期检查性能：使用浏览器的性能分析工具（例如 Chrome 的开发者工具）来检查性能瓶颈，并优化应用。

18. 控制粒子数量：如果你使用粒子系统，确保粒子数量不会过多，以避免性能下降。

19. 测试不同设备：在不同设备和浏览器上测试你的应用，以确保它在各种环境中都能正常运行。

## 当结合高德地图和Three.js创建3D地图应用时，以下是每个步骤的详细操作：

获取地理数据：
使用高德地图API进行地理数据获取，可根据需求选择合适的API接口，例如地理编码、地图服务、POI搜索等。
将API返回的地理数据保存为合适的格式，例如JSON格式，以便后续处理和使用。

地理数据转换：
如果需要将地理坐标转换为Three.js中的3D坐标，可以使用地理坐标系转换算法，将地理坐标映射到Three.js场景中的坐标系。
如果需要将地理特征转换为3D模型，可以使用地理数据和3D模型之间的映射关系，或者手动创建对应的3D模型并进行适当的缩放、旋转和定位。

创建3D场景：
使用Three.js创建一个空的3D场景，可以使用THREE.Scene()构造函数创建。
设置相机、光源等场景元素，以便后续展示地理数据。
在HTML页面中添加一个用于渲染场景的Canvas元素，并初始化Three.js渲染器。

地理数据可视化：
将获取到的地理数据转换为Three.js中的3D对象，例如点、线、面等。
将这些3D对象添加到场景中，以展示地理信息。可以使用Three.js提供的THREE.Mesh、THREE.Line等类来创建和添加3D对象。

交互功能：
实现用户与地图的交互功能，例如缩放、旋转、拖动等操作。可以监听鼠标或触摸事件，并根据用户的操作更新相机的位置和视角。
结合高德地图API提供的交互功能，例如地图缩放、平移等操作，与Three.js场景的交互功能进行结合。

性能优化：
优化地理数据的加载和处理过程，确保数据的加载和转换过程尽可能高效。
使用合适的3D模型和纹理，避免过多的渲染负载。
使用Three.js提供的性能监控工具，如Stats.js，对应用程序的性能进行监控和优化。

## threejs shader

Three.js是一个用于创建和显示3D图形的JavaScript库，它提供了丰富的功能和API，包括用于创建自定义着色器（Shader）的功能。

在Three.js中，你可以使用自定义着色器来实现各种特效、材质和渲染效果。自定义着色器通常使用GLSL（OpenGL Shading Language）编写，它是一种用于编写图形渲染管道的专用语言。下面是一些关于使用自定义着色器的基本步骤：

1. 编写着色器代码：使用GLSL编写顶点着色器和片元着色器代码。顶点着色器用于处理顶点的位置和属性，片元着色器用于处理每个像素的颜色和其他属性。

2. 创建ShaderMaterial：使用Three.js的ShaderMaterial类来创建一个包含自定义着色器的材质。在ShaderMaterial的构造函数中传入顶点着色器和片元着色器的代码字符串。

3. 应用材质：将ShaderMaterial应用到Three.js的3D对象上，以实现自定义的渲染效果。你可以将ShaderMaterial设置为Mesh的材质，或者将其应用到其他支持材质的对象上。

下面是一个简单的示例，演示了如何在Three.js中创建一个自定义的着色器效果：

```js
// 顶点着色器代码
const vertexShader = `
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

// 片元着色器代码
const fragmentShader = `
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 红色
    }
`;

// 创建ShaderMaterial
const material = new THREE.ShaderMaterial({
    vertexShader: vertexShader,
    fragmentShader: fragmentShader
});

// 创建一个立方体对象
const geometry = new THREE.BoxGeometry();
const cube = new THREE.Mesh(geometry, material);

// 将立方体添加到场景中
scene.add(cube);

```

## 什么是顶点着色器和片元着色器

顶点着色器（Vertex Shader）和片元着色器（Fragment Shader）是图形渲染管线中的两个重要组成部分，它们负责处理图形的顶点和片元（像素）的渲染过程。

1. 顶点着色器：

- 顶点着色器是图形渲染管线中的第一个阶段，它负责处理每个顶点的位置和属性。在顶点着色器中，你可以对顶点的位置、法线、颜色等进行计算和变换，并且可以将顶点的属性传递给后续的渲染阶段。
- 典型的顶点着色器会执行一些基本的几何变换，如平移、旋转、缩放，以及投影变换，将顶点从3D空间变换到2D屏幕空间。
- 顶点着色器的输出通常包括变换后的顶点位置（gl_Position），以及需要传递给片元着色器的其他属性。

2. 片元着色器：

- 片元着色器是图形渲染管线中的第二个阶段，它负责处理每个片元（像素）的颜色和其他属性。在片元着色器中，你可以计算片元的颜色、透明度、纹理坐标等。
- 典型的片元着色器会执行一些光照计算、纹理采样、颜色混合等操作，以确定每个片元最终的颜色值。
- 片元着色器的输出通常包括最终的颜色值（gl_FragColor），以及可能用于后续处理的其他属性。

顶点着色器和片元着色器共同工作，构成了图形渲染管线中的渲染过程。通过编写自定义的顶点着色器和片元着色器代码，你可以实现各种复杂的渲染效果，如光照、阴影、纹理映射、法线映射等，从而实现更加逼真和精细的图形渲染效果。

## 什么是vec4

vec4是GLSL（OpenGL Shading Language）中的一种数据类型，表示一个包含四个分量的向量（Vector）。每个分量通常代表颜色的RGBA（红、绿、蓝、Alpha透明度）值，也可以用来表示3D空间中的坐标或其他四维向量的数据。

在GLSL中，vec4通常用于表示像素的颜色、顶点的位置或法线等数据。它的语法形式如下：

```js
vec4 variableName;
vec4 variableName = vec4(x, y, z, w);
```
其中，variableName是变量的名称，可以是任意有效的标识符；(x, y, z, w)是向量的分量值，可以是标量、变量或表达式。

例如，下面是一个示例代码，演示了如何创建一个vec4类型的颜色向量：
```js
vec4 color = vec4(1.0, 0.0, 0.0, 1.0); // 红色，Alpha值为1.0，表示完全不透明

```
在这个示例中，color是一个vec4类型的变量，表示一个红色的颜色向量，其中RGBA分量依次为1.0、0.0、0.0和1.0，分别代表红色、绿色、蓝色和Alpha透明度
