<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>VUE2 VUE3面试题 | 前端食堂</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/assets/logo.png">
    <meta name="description" content="A lightweight creator for VuePress project.">
    <link rel="preload" href="/assets/css/0.styles.a0bdfdfc.css" as="style"><link rel="preload" href="/assets/js/app.59679b34.js" as="script"><link rel="preload" href="/assets/js/3.3c0ac5ed.js" as="script"><link rel="preload" href="/assets/js/24.01b1790c.js" as="script"><link rel="prefetch" href="/assets/js/10.391b4ff2.js"><link rel="prefetch" href="/assets/js/11.870cc05f.js"><link rel="prefetch" href="/assets/js/12.04bc9bae.js"><link rel="prefetch" href="/assets/js/13.31148c3d.js"><link rel="prefetch" href="/assets/js/14.309add8d.js"><link rel="prefetch" href="/assets/js/15.b6411078.js"><link rel="prefetch" href="/assets/js/16.61964171.js"><link rel="prefetch" href="/assets/js/17.9121600a.js"><link rel="prefetch" href="/assets/js/18.55a4d91d.js"><link rel="prefetch" href="/assets/js/19.873deb48.js"><link rel="prefetch" href="/assets/js/20.57bf3d68.js"><link rel="prefetch" href="/assets/js/21.c4d18654.js"><link rel="prefetch" href="/assets/js/22.c1b03a73.js"><link rel="prefetch" href="/assets/js/23.c57b404a.js"><link rel="prefetch" href="/assets/js/25.9818c95c.js"><link rel="prefetch" href="/assets/js/26.6e22247a.js"><link rel="prefetch" href="/assets/js/27.b9af3ca5.js"><link rel="prefetch" href="/assets/js/28.a2ef47a6.js"><link rel="prefetch" href="/assets/js/29.8b910510.js"><link rel="prefetch" href="/assets/js/30.da2baf23.js"><link rel="prefetch" href="/assets/js/31.487b4609.js"><link rel="prefetch" href="/assets/js/32.db8259b1.js"><link rel="prefetch" href="/assets/js/33.0d74a7ba.js"><link rel="prefetch" href="/assets/js/34.11bab9ae.js"><link rel="prefetch" href="/assets/js/35.5cbf3603.js"><link rel="prefetch" href="/assets/js/36.1fba2166.js"><link rel="prefetch" href="/assets/js/37.03e5b41c.js"><link rel="prefetch" href="/assets/js/38.ba603ca6.js"><link rel="prefetch" href="/assets/js/39.24e7d3ab.js"><link rel="prefetch" href="/assets/js/4.880ad7e4.js"><link rel="prefetch" href="/assets/js/40.2cbab052.js"><link rel="prefetch" href="/assets/js/41.4549e623.js"><link rel="prefetch" href="/assets/js/42.f7347106.js"><link rel="prefetch" href="/assets/js/43.53749e9c.js"><link rel="prefetch" href="/assets/js/44.cde2e67e.js"><link rel="prefetch" href="/assets/js/45.c1c5a6a5.js"><link rel="prefetch" href="/assets/js/46.29ea8780.js"><link rel="prefetch" href="/assets/js/47.01c6319d.js"><link rel="prefetch" href="/assets/js/48.7d82f043.js"><link rel="prefetch" href="/assets/js/49.92415a8b.js"><link rel="prefetch" href="/assets/js/5.87b8cba8.js"><link rel="prefetch" href="/assets/js/50.030efcaa.js"><link rel="prefetch" href="/assets/js/51.0443494e.js"><link rel="prefetch" href="/assets/js/52.08064753.js"><link rel="prefetch" href="/assets/js/53.f2fc4dba.js"><link rel="prefetch" href="/assets/js/54.3f455402.js"><link rel="prefetch" href="/assets/js/55.8083970c.js"><link rel="prefetch" href="/assets/js/56.33c48193.js"><link rel="prefetch" href="/assets/js/57.9496eced.js"><link rel="prefetch" href="/assets/js/58.81e43fc8.js"><link rel="prefetch" href="/assets/js/59.cd279592.js"><link rel="prefetch" href="/assets/js/6.94c3f75d.js"><link rel="prefetch" href="/assets/js/60.4146b94f.js"><link rel="prefetch" href="/assets/js/61.bd9b3459.js"><link rel="prefetch" href="/assets/js/62.529449be.js"><link rel="prefetch" href="/assets/js/63.4da1049b.js"><link rel="prefetch" href="/assets/js/64.9c66ea14.js"><link rel="prefetch" href="/assets/js/65.acb9f246.js"><link rel="prefetch" href="/assets/js/66.28e20029.js"><link rel="prefetch" href="/assets/js/67.9d8e3681.js"><link rel="prefetch" href="/assets/js/68.01f01e16.js"><link rel="prefetch" href="/assets/js/69.cd8d958a.js"><link rel="prefetch" href="/assets/js/7.c7f094c4.js"><link rel="prefetch" href="/assets/js/70.19f80ebc.js"><link rel="prefetch" href="/assets/js/71.52dfc81f.js"><link rel="prefetch" href="/assets/js/72.d967611c.js"><link rel="prefetch" href="/assets/js/8.27c5e273.js"><link rel="prefetch" href="/assets/js/9.ac0a10b2.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.12a14fc0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a0bdfdfc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">前端食堂</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><a class="ant-dropdown-link ant-dropdown-trigger">
      Hover me <i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></a> <a href="https://github.com/wjhuan/frontend-learn-route" target="_blank" rel="noopener noreferrer" class="repo-link"><i aria-label="icon: github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></i></a></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/interview/" aria-current="page" title="README.md" class="sidebar-link">README.md</a></li><li><a href="/interview/article-1.html" title="CSS面试题" class="sidebar-link">CSS面试题</a></li><li><a href="/interview/article-2.html" title="DOM和BOM面试题" class="sidebar-link">DOM和BOM面试题</a></li><li><a href="/interview/article-3.html" title="webpack和babel面试题" class="sidebar-link">webpack和babel面试题</a></li><li><a href="/interview/article-4.html" title="js面试题" class="sidebar-link">js面试题</a></li><li><a href="/interview/article-5.html" title="网络面试题" class="sidebar-link">网络面试题</a></li><li><a href="/interview/article-6.html" aria-current="page" title="VUE2 VUE3面试题" class="active sidebar-link">VUE2 VUE3面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/article-6.html#vue-computed-和-watch-区别" title="Vue computed 和 watch 区别" class="sidebar-link">Vue computed 和 watch 区别</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#vue-组件通讯" title="Vue 组件通讯" class="sidebar-link">Vue 组件通讯</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#vuex-mutation-action-区别" title="Vuex mutation action 区别" class="sidebar-link">Vuex mutation action 区别</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#vue-生命周期" title="Vue 生命周期" class="sidebar-link">Vue 生命周期</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#vue-router-模式" title="Vue-router 模式" class="sidebar-link">Vue-router 模式</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#你在实际工作中-做过哪些-vue-优化" title="你在实际工作中，做过哪些 Vue 优化？" class="sidebar-link">你在实际工作中，做过哪些 Vue 优化？</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#连环问-vue-遇到过哪些坑" title="连环问：Vue 遇到过哪些坑？？？" class="sidebar-link">连环问：Vue 遇到过哪些坑？？？</a></li><li class="sidebar-sub-header"><a href="/interview/article-6.html#vue-错误监听" title="Vue 错误监听" class="sidebar-link">Vue 错误监听</a></li></ul></li><li><a href="/interview/article-7.html" title="nodejs 面试题" class="sidebar-link">nodejs 面试题</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="vue2-vue3-面试题"><a href="#vue2-vue3-面试题" class="header-anchor">#</a> VUE2 VUE3 面试题</h1> <h2 id="vue-computed-和-watch-区别"><a href="#vue-computed-和-watch-区别" class="header-anchor">#</a> Vue computed 和 watch 区别</h2> <h3 id="两者设计用途不同"><a href="#两者设计用途不同" class="header-anchor">#</a> 两者设计用途不同</h3> <ul><li>computed 用于产出二次处理之后的数据，如对于一个列表进行 filter 处理</li> <li>watch 用于监听数据变化（如 v-model 时，数据可能被动改变，需要监听才能拿到）</li></ul> <h3 id="computed-有缓存"><a href="#computed-有缓存" class="header-anchor">#</a> computed 有缓存</h3> <ul><li>computed 有缓存，data 不变则缓存不失效</li> <li>methods 无缓存，实时计算</li></ul> <h3 id="答案"><a href="#答案" class="header-anchor">#</a> 答案</h3> <ul><li>computed 就已有数据产出新数据，有缓存</li> <li>watch 监听已有数据</li></ul> <h2 id="vue-组件通讯"><a href="#vue-组件通讯" class="header-anchor">#</a> Vue 组件通讯</h2> <h3 id="props-emit"><a href="#props-emit" class="header-anchor">#</a> props / $emit</h3> <p>适用于父子组件。</p> <ul><li>父组件向子组件传递 props 和事件</li> <li>子组件接收 props ，使用 <code>this.$emit</code> 调用事件</li></ul> <h3 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h3> <p>适用于兄弟组件，或者“距离”较远的组件。</p> <p>常用 API</p> <ul><li>绑定事件 <code>event.on(key, fn)</code> 或 <code>event.once(key, fn)</code></li> <li>触发事件 <code>event.emit(key, data)</code></li> <li>解绑事件 <code>event.off(key, fn)</code></li></ul> <p>Vue 版本的区别</p> <ul><li>Vue 2.x 可以使用 Vue 实例作为自定义事件</li> <li>Vue 3.x 需要使用第三方的自定义事件，例如 https://www.npmjs.com/package/event-emitter</li></ul> <p>【注意】组件销毁时记得 <code>off</code> 事件，否则可能会造成内存泄漏</p> <h3 id="attrs"><a href="#attrs" class="header-anchor">#</a> $attrs</h3> <p><code>$attrs</code> 存储是父组件中传递过来的，且未在 <code>props</code> 和 <code>emits</code> 中定义的属性和事件。<br>
相当于 <code>props</code> 和 <code>emits</code> 的一个补充。</p> <p>继续向下级传递，可以使用 <code>v-bind=&quot;$attrs&quot;</code>。这会在下级组件中渲染 DOM 属性，可以用 <code>inheritAttrs: false</code> 避免。</p> <p>【注意】Vue3 中移除了 <code>$listeners</code> ，合并到了 <code>$attrs</code> 中。</p> <h3 id="parent"><a href="#parent" class="header-anchor">#</a> $parent</h3> <p>通过 <code>this.$parent</code> 可以获取父组件，并可以继续获取属性、调用方法等。</p> <p>【注意】Vue3 中移除了 <code>$children</code> ，建议使用 <code>$refs</code></p> <h3 id="refs"><a href="#refs" class="header-anchor">#</a> $refs</h3> <p>通过 <code>this.$refs.xxx</code> 可以获取某个子组件，前提是模板中要设置 <code>ref=&quot;xxx&quot;</code>。</p> <p>【注意】要在 <code>mounted</code> 中获取 <code>this.$refs</code> ，不能在 <code>created</code> 中获取。</p> <h3 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> provide / inject</h3> <p>父子组件通讯方式非常多。如果是多层级的上下级组件通讯，可以使用 provide 和 inject 。<br>
在上级组件定一个 provide ，下级组件即可通过 inject 接收。</p> <ul><li>传递静态数据直接使用 <code>provide: { x: 10 }</code> 形式</li> <li>传递组件数据需要使用 <code>provide() { return { x: this.xx } }</code> 形式，但做不到响应式</li> <li>响应式需要借助 <code>computed</code> 来支持</li></ul> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h3> <p>Vuex 全局数据管理</p> <h3 id="答案-2"><a href="#答案-2" class="header-anchor">#</a> 答案</h3> <ul><li>父子组件通讯
<ul><li><code>props</code> <code>emits</code> <code>this.$emit</code></li> <li><code>$attrs</code> （也可以通过 <code>v-bind=&quot;$attrs&quot;</code> 向下级传递）</li> <li><code>$parent</code> <code>$refs</code></li></ul></li> <li>多级组件上下级
<ul><li><code>provide</code> <code>inject</code></li></ul></li> <li>跨级、全局
<ul><li>自定义事件</li> <li>Vuex</li></ul></li></ul> <h2 id="vuex-mutation-action-区别"><a href="#vuex-mutation-action-区别" class="header-anchor">#</a> Vuex mutation action 区别</h2> <h3 id="答案-3"><a href="#答案-3" class="header-anchor">#</a> 答案</h3> <ul><li>mutation
<ul><li>建议原子操作，每次只修改一个数据，不要贪多</li> <li>必须是同步代码，方便查看 devTools 中的状态变化</li></ul></li> <li>action
<ul><li>可包含多个 mutation</li> <li>可以是异步操作</li></ul></li></ul> <p>Vue 每个生命周期都做了什么</p> <h2 id="vue-生命周期"><a href="#vue-生命周期" class="header-anchor">#</a> Vue 生命周期</h2> <p><img src="/assets/img/vue-lifecycle.bc5ef8df.png" alt=""></p> <h3 id="beforecreate"><a href="#beforecreate" class="header-anchor">#</a> beforeCreate</h3> <p>初始化一个空的 Vue 实例，<code>data</code> <code>methods</code> 等尚未被初始化，无法调用。</p> <h3 id="created"><a href="#created" class="header-anchor">#</a> created</h3> <p>Vue 实例初始化完成，<code>data</code> <code>methods</code> 都已初始化完成，可调用。<br>
但尚未开始渲染模板。</p> <h3 id="beforemount"><a href="#beforemount" class="header-anchor">#</a> beforeMount</h3> <p>编译模板，调用 <code>render</code> 函数生成 vdom ，但还没有开始渲染 DOM</p> <h3 id="mounted"><a href="#mounted" class="header-anchor">#</a> mounted</h3> <p>渲染 DOM 完成，页面更新。组件创建完成，开始进入运行阶段。</p> <h3 id="beforeupdate"><a href="#beforeupdate" class="header-anchor">#</a> beforeUpdate</h3> <p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。</p> <h3 id="updated"><a href="#updated" class="header-anchor">#</a> updated</h3> <p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</p> <p>注意，尽量不要在 <code>updated</code> 中继续修改数据，否则可能会触发死循环。</p> <h3 id="onactivated"><a href="#onactivated" class="header-anchor">#</a> onActivated</h3> <p>被 <code>keep-alive</code> 缓存的组件激活时调用。</p> <h3 id="ondeactivated"><a href="#ondeactivated" class="header-anchor">#</a> onDeactivated</h3> <p>被 <code>keep-alive</code> 缓存的组件停用时调用。</p> <h3 id="beforeunmount"><a href="#beforeunmount" class="header-anchor">#</a> beforeUnmount</h3> <p>组件进入销毁阶段。</p> <p>卸载组件实例后调用，在这个阶段，实例仍然是完全正常的。<br>
移除、解绑一些全局事件、自定义事件，可以在此时操作。</p> <h3 id="unmounted"><a href="#unmounted" class="header-anchor">#</a> unmounted</h3> <p>卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</p> <hr> <h3 id="连环问-如何正确的操作-dom"><a href="#连环问-如何正确的操作-dom" class="header-anchor">#</a> 连环问：如何正确的操作 DOM</h3> <p><code>mounted</code> 和 <code>updated</code> 都不会保证所有子组件都挂载完成，如果想等待所有视图都渲染完成，需要使用 <code>$nextTick</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仅在整个视图都被渲染之后才会运行的代码</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="连环问-ajax-放在哪个生命周期合适"><a href="#连环问-ajax-放在哪个生命周期合适" class="header-anchor">#</a> 连环问：ajax 放在哪个生命周期合适？</h3> <p>一般有两个选择：<code>created</code> 和 <code>mounted</code> ，建议选择后者 <code>mounted</code> 。</p> <p>执行速度</p> <ul><li>从理论上来说，放在 <code>created</code> 确实会快一些</li> <li>但 ajax 是网络请求，其时间是主要的影响因素。从 <code>created</code> 到 <code>mounted</code> 是 JS 执行，速度非常快。</li> <li>所以，两者在执行速度上不会有肉眼可见的差距</li></ul> <p>代码的阅读和理解</p> <ul><li>放在 <code>created</code> 却会带来一些沟通和理解成本，从代码的执行上来看，它会一边执行组件渲染，一边触发网络请求，并行</li> <li>放在 <code>mounted</code> 就是等待 DOM 渲染完成再执行网络请求，串行，好理解</li></ul> <p>所以，综合来看，更建议选择 <code>mounted</code> 。</p> <h3 id="连环问-composition-api-生命周期有何不同"><a href="#连环问-composition-api-生命周期有何不同" class="header-anchor">#</a> 连环问：Composition API 生命周期有何不同</h3> <ul><li><code>setup</code> 代替了 <code>beforeCreate</code> 和 <code>created</code></li> <li>生命周期换成了函数的形式，如 <code>mounted</code> -&gt; <code>onMounted</code> 参考 https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onUpdated<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mounted'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-router-模式"><a href="#vue-router-模式" class="header-anchor">#</a> Vue-router 模式</h2> <h3 id="v4-的升级"><a href="#v4-的升级" class="header-anchor">#</a> v4 的升级</h3> <p>Vue-router v4 升级之后，<code>mode: 'xxx'</code> 替换为 API 的形式，但功能是一样的</p> <ul><li><code>mode: 'hash'</code> 替换为 <code>createWebHashHistory()</code></li> <li><code>mode: 'history'</code> 替换为 <code>createWebHistory()</code></li> <li><code>mode: 'abstract'</code> 替换为 <code>createMemoryHistory()</code></li></ul> <p>PS：个人感觉，叫 <code>memory</code> 比叫 <code>abstract</code> 更易理解，前者顾名思义，后者就过于抽象。</p> <h3 id="hash"><a href="#hash" class="header-anchor">#</a> hash</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// http://127.0.0.1:8881/hash.html?a=100&amp;b=20#/aaa/bbb</span>
location<span class="token punctuation">.</span>protocol <span class="token comment">// 'http:'</span>
location<span class="token punctuation">.</span>hostname <span class="token comment">// '127.0.0.1'</span>
location<span class="token punctuation">.</span>host <span class="token comment">// '127.0.0.1:8881'</span>
location<span class="token punctuation">.</span>port <span class="token comment">// '8881'</span>
location<span class="token punctuation">.</span>pathname <span class="token comment">// '/hash.html'</span>
location<span class="token punctuation">.</span>search <span class="token comment">// '?a=100&amp;b=20'</span>
location<span class="token punctuation">.</span>hash <span class="token comment">// '#/aaa/bbb'</span>
</code></pre></div><p>hash 的特点</p> <ul><li>会触发页面跳转，可使用浏览器的“后退” “前进”</li> <li>但不会刷新页面，支持 SPA 必须的特性</li> <li>hash 不会被提交到 server 端（因此刷新页面也会命中当前页面，让前端根据 hash 处理路由）</li></ul> <p>url 中的 hash ，是不会发送给 server 端的。前端 <code>onhashchange</code> 拿到自行处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 页面初次加载，获取 hash</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hash'</span><span class="token punctuation">,</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// hash 变化，包括：</span>
<span class="token comment">// a. JS 修改 url</span>
<span class="token comment">// b. 手动修改 url 的 hash</span>
<span class="token comment">// c. 浏览器前进、后退</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'old url'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>oldURL<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new url'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hash'</span><span class="token punctuation">,</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="h5-history-api"><a href="#h5-history-api" class="header-anchor">#</a> H5 history API</h3> <p>常用的两个 API</p> <ul><li><code>history.pushState</code></li> <li><code>window.onpopstate</code></li></ul> <p>页面刷新时，<strong>服务端要做处理</strong>，可参考<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener noreferrer">文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。。即无论什么 url 访问 server ，都要返回该页面。</p> <p>按照 url 规范，不同的 url 对应不同的资源，例如：</p> <ul><li><code>https://github.com/</code> server 返回首页</li> <li><code>https://github.com/username/</code> server 返回用户页</li> <li><code>https://github.com/username/project1/</code> server 返回项目页</li></ul> <p>但是用了 SPA 的前端路由，就改变了这一规则，假如 github 用了的话：</p> <ul><li><code>https://github.com/</code> server 返回首页</li> <li><code>https://github.com/username/</code> server 返回首页，前端路由跳转到用户页</li> <li><code>https://github.com/username/project1/</code> server 返回首页，前端路由跳转到项目页</li></ul> <p>所以，从开发者的实现角度来看，前端路由是一个违反规则的形式。
但是从不关心后端，只关心前端页面的用户，或者浏览器来看，更喜欢 <code>pushState</code> 这种方式。</p> <p>代码参考 history-api.html</p> <h3 id="三种模式的区别"><a href="#三种模式的区别" class="header-anchor">#</a> 三种模式的区别</h3> <ul><li>hash - 使用 url hash 变化记录路由地址</li> <li>history - 使用 H5 history API 来改 url 记录路由地址</li> <li>abstract - 不修改 url ，路由地址在内存中，<strong>但页面刷新会重新回到首页</strong>。</li></ul> <h2 id="你在实际工作中-做过哪些-vue-优化"><a href="#你在实际工作中-做过哪些-vue-优化" class="header-anchor">#</a> 你在实际工作中，做过哪些 Vue 优化？</h2> <h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="header-anchor">#</a> v-if 和 v-show</h3> <p>区别</p> <ul><li><code>v-if</code> 组件销毁/重建</li> <li><code>v-show</code> 组件隐藏（切换 CSS <code>display</code>）</li></ul> <p>场景</p> <ul><li>一般情况下使用 <code>v-if</code> 即可，普通组件的销毁、渲染不会造成性能问题</li> <li>如果组件创建时需要大量计算，或者大量渲染（如复杂的编辑器、表单、地图等），可以考虑 <code>v-show</code></li></ul> <h3 id="v-for-使用-key"><a href="#v-for-使用-key" class="header-anchor">#</a> v-for 使用 key</h3> <p><code>key</code> 可以优化内部的 diff 算法。注意，遍历数组时 <code>key</code> 不要使用 <code>index</code> 。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 而且，key 不要用 index --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(id, name) in list<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h3 id="computed-缓存"><a href="#computed-缓存" class="header-anchor">#</a> computed 缓存</h3> <p><code>computed</code> 可以缓存计算结果，<code>data</code> 不变则缓存不失效。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">msgList</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token operator">...</span> <span class="token punctuation">]</span> <span class="token comment">// 消息列表</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 未读消息的数量</span>
        <span class="token function">unreadCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">m</span> <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>read <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h3> <p><code>&lt;keep-alive&gt;</code> 可以缓存子组件，只创建一次。通过 <code>activated</code> 和 <code>deactivated</code> 生命周期监听是否显示状态。<br>
代码参考 components/KeepAlive/index.vue</p> <p>场景</p> <ul><li>局部频繁切换的组件，如 tabs</li> <li>不可乱用 <code>&lt;keep-alive&gt;</code> ，缓存太多会占用大量内存，而且出问题不好 debug</li></ul> <h3 id="异步组件"><a href="#异步组件" class="header-anchor">#</a> 异步组件</h3> <p>对于体积大的组件（如编辑器、表单、地图等）可以使用异步组件</p> <ul><li>拆包，需要时异步加载，不需要时不加载</li> <li>减少 main 包的体积，页面首次加载更快</li></ul> <p>vue3 使用 <code>defineAsyncComponent</code> 加载异步组件，代码参考 components/AsyncComponent/index.vue</p> <h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <p>对于一些补偿访问的路由，或者组件提交比较大的路由，可以使用路由懒加载。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Home'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span> Home
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>
    <span class="token comment">// 路由懒加载</span>
    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="token string">'../views/About.vue'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><h3 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h3> <p>SSR 让网页访问速度更快，对 SEO 友好。</p> <p>但 SSR 使用和调试成本高，不可乱用。例如，一个低代码项目（在线制作 H5 网页），toB 部分不可用 SSR ， toC 部分适合用 SSR 。</p> <h3 id="答案-4"><a href="#答案-4" class="header-anchor">#</a> 答案</h3> <ul><li>v-if 和 v-show</li> <li>v-for 使用 key</li> <li>computed 缓存</li> <li>keep-alive</li> <li>异步组件</li> <li>路由懒加载</li> <li>SSR</li></ul> <h2 id="连环问-vue-遇到过哪些坑"><a href="#连环问-vue-遇到过哪些坑" class="header-anchor">#</a> 连环问：Vue 遇到过哪些坑？？？</h2> <p>全局事件、自定义事件要在组件销毁时解除绑定</p> <ul><li>内存泄漏风险</li> <li>全局事件（如 <code>window.resize</code>）不解除，则会继续监听，而且组件再次创建时会重复绑定</li></ul> <p>Vue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— Vue3 不会有这个问题</p> <ul><li>新增 data 属性，需要用 <code>Vue.set</code></li> <li>删除 data 属性，需要用 <code>Vue.delete</code></li> <li>修改数组某一元素，不能 <code>arr[index] = value</code> ，要使用 <code>arr.splice</code> API 方式</li></ul> <p>路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 SPA 都会有这个问题，并不仅仅是 Vue 。</p> <ul><li>在列表页缓存数据和 <code>scrollTop</code></li> <li>返回列表页时（用 Vue-router <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">导航守卫<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，判断 <code>from</code>），使用缓存数据渲染页面，然后 <code>scrollTo(scrollTop)</code></li></ul> <h2 id="vue-错误监听"><a href="#vue-错误监听" class="header-anchor">#</a> Vue 错误监听</h2> <h3 id="window-onerror"><a href="#window-onerror" class="header-anchor">#</a> window.onerror</h3> <p>可以监听当前页面所有的 JS 报错，jQuery 时代经常用。<br>
注意，全局只绑定一次即可。不要放在多次渲染的组件中，这样容易绑定多次。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg<span class="token punctuation">,</span> source<span class="token punctuation">,</span> line<span class="token punctuation">,</span> column<span class="token punctuation">,</span> error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'window.onerror---------'</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> source<span class="token punctuation">,</span> line<span class="token punctuation">,</span> column<span class="token punctuation">,</span> error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 注意，如果用 window.addEventListener('error', event =&gt; {}) 参数不一样！！！</span>
</code></pre></div><h3 id="errorcaptured-生命周期"><a href="#errorcaptured-生命周期" class="header-anchor">#</a> errorCaptured 生命周期</h3> <p>会监听所有<strong>下级组件</strong>的错误。可以返回 <code>false</code> 阻止向上传播，因为可能会有多个上级节点都监听错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">errorCaptured</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'errorCaptured--------'</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="errorhandler"><a href="#errorhandler" class="header-anchor">#</a> errorHandler</h3> <p>全局的错误监听，所有组件的报错都会汇总到这里来。PS：如果 <code>errorCaptured</code> 返回 <code>false</code> 则<strong>不会</strong>到这里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token function-variable function">errorHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'errorHandler--------'</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> info<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请注意，<code>errorHandler</code> 会阻止错误走向 <code>window.onerror</code>。</p> <p>PS：还有 <code>warnHandler</code></p> <h3 id="异步错误"><a href="#异步错误" class="header-anchor">#</a> 异步错误</h3> <p>组件内的异步错误 <code>errorHandler</code> 监听不到，还是需要 <code>window.onerror</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'setTimeout 报错'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="答案-5"><a href="#答案-5" class="header-anchor">#</a> 答案</h3> <p>方式</p> <ul><li><code>errorCaptured</code> 监听下级组件的错误，可返回 <code>false</code> 阻止向上传播</li> <li><code>errorHandler</code> 监听 Vue 全局错误</li> <li><code>window.onerror</code> 监听其他的 JS 错误，如异步</li></ul> <p>建议：结合使用</p> <ul><li>一些重要的、复杂的、有运行风险的组件，可使用 <code>errorCaptured</code> 重点监听</li> <li>然后用 <code>errorHandler</code> <code>window.onerror</code> 候补全局监听，避免意外情况</li></ul> <h3 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展</h3> <p>Promise 监听报错要使用 <code>window.onunhandledrejection</code></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/21/2023, 4:35:13 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/interview/article-5.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        网络面试题
      </a></span> <span class="next"><a href="/interview/article-7.html">
        nodejs 面试题
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.59679b34.js" defer></script><script src="/assets/js/3.3c0ac5ed.js" defer></script><script src="/assets/js/24.01b1790c.js" defer></script>
  </body>
</html>