(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{884:function(v,_,e){"use strict";e.r(_);var o=e(125),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"event-loop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[v._v("#")]),v._v(" Event Loop")]),v._v(" "),e("h2",{attrs:{id:"进程与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[v._v("#")]),v._v(" 进程与线程")]),v._v(" "),e("ul",[e("li",[v._v("进程计算机分配任务的和调度的任务最小单位，浏览器是一个多进程模型，每个页卡都是一个独立的进程 （更稳定）")]),v._v(" "),e("li",[v._v("把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如"),e("code",[v._v("渲染线程")]),v._v("、"),e("code",[v._v("JS 引擎线程")]),v._v("、"),e("code",[v._v("HTTP 请求线程")]),v._v("等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),v._v(" "),e("li",[e("code",[v._v("JS")]),v._v("是单线程的？只是主线程是单线程的。")])]),v._v(" "),e("p",[v._v("线程包括哪些")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("GUI")]),v._v("渲染，页面渲染，绘图，绘制，"),e("code",[v._v("3d")]),v._v("动画")]),v._v(" "),e("li",[e("code",[v._v("js")]),v._v("渲染引擎：执行 "),e("code",[v._v("js")]),v._v(" 代码，当 "),e("code",[v._v("js")]),v._v(" 执行时渲染线程会挂起"),e("code",[v._v("=>")]),v._v("渲染时不能执行"),e("code",[v._v("js")])]),v._v(" "),e("li",[v._v("事件触发线程 "),e("code",[v._v("EventLoop")])]),v._v(" "),e("li",[e("code",[v._v("webApi")]),v._v(" 也会创建线程："),e("code",[v._v("事件")]),v._v("、"),e("code",[v._v("定时器")]),v._v("、"),e("code",[v._v("ajax请求")]),v._v("都会创造一个线程")]),v._v(" "),e("li",[e("code",[v._v("webworker")])])]),v._v(" "),e("blockquote",[e("p",[v._v("微任务队列每次都会创建一个全新的队列、事件队列仅有一个")])]),v._v(" "),e("ul",[e("li",[v._v("事件队列、消息队列：存放定时器到达时间的回调函数、"),e("code",[v._v("ajax")]),v._v("回调成功的函数等")]),v._v(" "),e("li",[v._v("事件循环：不断检测调用栈是否为空，如果为空则从事件对列中取出一个来执行")])]),v._v(" "),e("h2",{attrs:{id:"宏任务和微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[v._v("#")]),v._v(" 宏任务和微任务")]),v._v(" "),e("ul",[e("li",[v._v("宏任务 "),e("code",[v._v("script")]),v._v("、"),e("code",[v._v("ui 渲染")]),v._v("、"),e("code",[v._v("setTimeout")]),v._v("、"),e("code",[v._v("setInterval")]),v._v("、"),e("code",[v._v("postMessage")]),v._v("、"),e("code",[v._v("MessageChannel")]),v._v("、"),e("code",[v._v("setImmediate")])]),v._v(" "),e("li",[v._v("微任务 "),e("code",[v._v("promise")]),v._v("、"),e("code",[v._v("mutationObserver")]),v._v("、"),e("code",[v._v("process.nextTick(node)")])])]),v._v(" "),e("blockquote",[e("p",[v._v("每循环一次会执行一个宏任务，并清空对应的微任务队列，每次事件循环完毕后会判断页面是否需要重新渲染 （大约16.6ms会渲染一次）")])]),v._v(" "),e("ol",[e("li",[v._v("先执行"),e("code",[v._v("script")]),v._v("脚本，将宏任务和微任务进行分类，如果调用的是浏览器"),e("code",[v._v("api")]),v._v("，浏览器会开一个线程，等时间到了，会自动的放入到宏任务队列中，微任务是直接放到微任务队列中的")]),v._v(" "),e("li",[e("code",[v._v("js")]),v._v("执行完毕后，会清空所有的微任务，如果微任务在产生微任务，会放到当前微任务队列的尾部")]),v._v(" "),e("li",[v._v("如果页面需要渲染，则会执行渲染流程")]),v._v(" "),e("li",[v._v("事件触发线程会不停的扫描宏任务队列，如果宏任务队列中有对应的回调，会取出来执行一个，继续执行上述过程")]),v._v(" "),e("li",[v._v("宏任务每次调用一个，微任务是请空所有")])]),v._v(" "),e("blockquote",[e("p",[v._v("微任务队列每次执行宏任务 都会创造一个新的队列，宏任务队列只有一个")])])])}),[],!1,null,null,null);_.default=t.exports}}]);